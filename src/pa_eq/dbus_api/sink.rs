// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

#![allow(dead_code)]
use dbus as dbus;
use dbus::arg;
use dbus::tree;

pub trait OrgPulseAudioExtEqualizing1Equalizer {
    type Err;
    fn filter_at_points(&self, channel: u32, xs: Vec<u32>) -> Result<(Vec<f64>, f64), Self::Err>;
    fn seed_filter(&self, channel: u32, xs: Vec<u32>, ys: Vec<f64>, preamp: f64) -> Result<(), Self::Err>;
    fn save_profile(&self, channel: u32, name: &str) -> Result<(), Self::Err>;
    fn load_profile(&self, channel: u32, name: &str) -> Result<(), Self::Err>;
    fn set_filter(&self, channel: u32, ys: Vec<f64>, preamp: f64) -> Result<(), Self::Err>;
    fn get_filter(&self, channel: u32) -> Result<(Vec<f64>, f64), Self::Err>;
    fn save_state(&self) -> Result<(), Self::Err>;
    fn base_profile(&self, channel: u32) -> Result<String, Self::Err>;
    fn get_interface_revision(&self) -> Result<u32, Self::Err>;
    fn get_sample_rate(&self) -> Result<u32, Self::Err>;
    fn get_filter_sample_rate(&self) -> Result<u32, Self::Err>;
    fn get_nfilter_coefficients(&self) -> Result<u32, Self::Err>;
    fn get_nchannels(&self) -> Result<u32, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgPulseAudioExtEqualizing1Equalizer for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn filter_at_points(&self, channel: u32, xs: Vec<u32>) -> Result<(Vec<f64>, f64), Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.PulseAudio.Ext.Equalizing1.Equalizer".into(), &"FilterAtPoints".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(channel);
            i.append(xs);
        }));
        r#try!(m.as_result());
        let mut i = m.iter_init();
        let ys: Vec<f64> = r#try!(i.read());
        let preamp: f64 = r#try!(i.read());
        Ok((ys, preamp))
    }

    fn seed_filter(&self, channel: u32, xs: Vec<u32>, ys: Vec<f64>, preamp: f64) -> Result<(), Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.PulseAudio.Ext.Equalizing1.Equalizer".into(), &"SeedFilter".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(channel);
            i.append(xs);
            i.append(ys);
            i.append(preamp);
        }));
        r#try!(m.as_result());
        Ok(())
    }

    fn save_profile(&self, channel: u32, name: &str) -> Result<(), Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.PulseAudio.Ext.Equalizing1.Equalizer".into(), &"SaveProfile".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(channel);
            i.append(name);
        }));
        r#try!(m.as_result());
        Ok(())
    }

    fn load_profile(&self, channel: u32, name: &str) -> Result<(), Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.PulseAudio.Ext.Equalizing1.Equalizer".into(), &"LoadProfile".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(channel);
            i.append(name);
        }));
        r#try!(m.as_result());
        Ok(())
    }

    fn set_filter(&self, channel: u32, ys: Vec<f64>, preamp: f64) -> Result<(), Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.PulseAudio.Ext.Equalizing1.Equalizer".into(), &"SetFilter".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(channel);
            i.append(ys);
            i.append(preamp);
        }));
        r#try!(m.as_result());
        Ok(())
    }

    fn get_filter(&self, channel: u32) -> Result<(Vec<f64>, f64), Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.PulseAudio.Ext.Equalizing1.Equalizer".into(), &"GetFilter".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(channel);
        }));
        r#try!(m.as_result());
        let mut i = m.iter_init();
        let ys: Vec<f64> = r#try!(i.read());
        let preamp: f64 = r#try!(i.read());
        Ok((ys, preamp))
    }

    fn save_state(&self) -> Result<(), Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.PulseAudio.Ext.Equalizing1.Equalizer".into(), &"SaveState".into(), |_| {
        }));
        r#try!(m.as_result());
        Ok(())
    }

    fn base_profile(&self, channel: u32) -> Result<String, Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.PulseAudio.Ext.Equalizing1.Equalizer".into(), &"BaseProfile".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(channel);
        }));
        r#try!(m.as_result());
        let mut i = m.iter_init();
        let name: String = r#try!(i.read());
        Ok(name)
    }

    fn get_interface_revision(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Ext.Equalizing1.Equalizer", "InterfaceRevision")
    }

    fn get_sample_rate(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Ext.Equalizing1.Equalizer", "SampleRate")
    }

    fn get_filter_sample_rate(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Ext.Equalizing1.Equalizer", "FilterSampleRate")
    }

    fn get_nfilter_coefficients(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Ext.Equalizing1.Equalizer", "NFilterCoefficients")
    }

    fn get_nchannels(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Ext.Equalizing1.Equalizer", "NChannels")
    }
}

pub fn org_pulse_audio_ext_equalizing1_equalizer_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgPulseAudioExtEqualizing1Equalizer<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.PulseAudio.Ext.Equalizing1.Equalizer", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let channel: u32 = r#try!(i.read());
        let xs: Vec<u32> = r#try!(i.read());
        let d = fclone(minfo);
        let (ys, preamp) = r#try!(d.filter_at_points(channel, xs));
        let rm = minfo.msg.method_return();
        let rm = rm.append1(ys);
        let rm = rm.append1(preamp);
        Ok(vec!(rm))
    };
    let m = factory.method("FilterAtPoints", Default::default(), h);
    let m = m.in_arg(("channel", "u"));
    let m = m.in_arg(("xs", "au"));
    let m = m.out_arg(("ys", "ad"));
    let m = m.out_arg(("preamp", "d"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let channel: u32 = r#try!(i.read());
        let xs: Vec<u32> = r#try!(i.read());
        let ys: Vec<f64> = r#try!(i.read());
        let preamp: f64 = r#try!(i.read());
        let d = fclone(minfo);
        r#try!(d.seed_filter(channel, xs, ys, preamp));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SeedFilter", Default::default(), h);
    let m = m.in_arg(("channel", "u"));
    let m = m.in_arg(("xs", "au"));
    let m = m.in_arg(("ys", "ad"));
    let m = m.in_arg(("preamp", "d"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let channel: u32 = r#try!(i.read());
        let name: &str = r#try!(i.read());
        let d = fclone(minfo);
        r#try!(d.save_profile(channel, name));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SaveProfile", Default::default(), h);
    let m = m.in_arg(("channel", "u"));
    let m = m.in_arg(("name", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let channel: u32 = r#try!(i.read());
        let name: &str = r#try!(i.read());
        let d = fclone(minfo);
        r#try!(d.load_profile(channel, name));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("LoadProfile", Default::default(), h);
    let m = m.in_arg(("channel", "u"));
    let m = m.in_arg(("name", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let channel: u32 = r#try!(i.read());
        let ys: Vec<f64> = r#try!(i.read());
        let preamp: f64 = r#try!(i.read());
        let d = fclone(minfo);
        r#try!(d.set_filter(channel, ys, preamp));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetFilter", Default::default(), h);
    let m = m.in_arg(("channel", "u"));
    let m = m.in_arg(("ys", "ad"));
    let m = m.in_arg(("preamp", "d"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let channel: u32 = r#try!(i.read());
        let d = fclone(minfo);
        let (ys, preamp) = r#try!(d.get_filter(channel));
        let rm = minfo.msg.method_return();
        let rm = rm.append1(ys);
        let rm = rm.append1(preamp);
        Ok(vec!(rm))
    };
    let m = factory.method("GetFilter", Default::default(), h);
    let m = m.in_arg(("channel", "u"));
    let m = m.out_arg(("ys", "ad"));
    let m = m.out_arg(("preamp", "d"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        r#try!(d.save_state());
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SaveState", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let channel: u32 = r#try!(i.read());
        let d = fclone(minfo);
        let name = r#try!(d.base_profile(channel));
        let rm = minfo.msg.method_return();
        let rm = rm.append1(name);
        Ok(vec!(rm))
    };
    let m = factory.method("BaseProfile", Default::default(), h);
    let m = m.in_arg(("channel", "u"));
    let m = m.out_arg(("name", "s"));
    let i = i.add_m(m);

    let p = factory.property::<u32, _>("InterfaceRevision", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_interface_revision()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("SampleRate", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_sample_rate()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("FilterSampleRate", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_filter_sample_rate()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NFilterCoefficients", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_nfilter_coefficients()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NChannels", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_nchannels()));
        Ok(())
    });
    let i = i.add_p(p);
    i
}

#[derive(Debug, Default)]
pub struct OrgPulseAudioExtEqualizing1EqualizerFilterChanged {
}

impl dbus::SignalArgs for OrgPulseAudioExtEqualizing1EqualizerFilterChanged {
    const NAME: &'static str = "FilterChanged";
    const INTERFACE: &'static str = "org.PulseAudio.Ext.Equalizing1.Equalizer";
    fn append(&self, _: &mut arg::IterAppend) {
    }
    fn get(&mut self, _: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgPulseAudioExtEqualizing1EqualizerSinkReconfigured {
}

impl dbus::SignalArgs for OrgPulseAudioExtEqualizing1EqualizerSinkReconfigured {
    const NAME: &'static str = "SinkReconfigured";
    const INTERFACE: &'static str = "org.PulseAudio.Ext.Equalizing1.Equalizer";
    fn append(&self, _: &mut arg::IterAppend) {
    }
    fn get(&mut self, _: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        Ok(())
    }
}

pub trait OrgPulseAudioCore1Device {
    type Err;
    fn suspend(&self, suspend: bool) -> Result<(), Self::Err>;
    fn get_port_by_name(&self, name: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_index(&self) -> Result<u32, Self::Err>;
    fn get_name(&self) -> Result<String, Self::Err>;
    fn get_driver(&self) -> Result<String, Self::Err>;
    fn get_owner_module(&self) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_card(&self) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_sample_format(&self) -> Result<u32, Self::Err>;
    fn get_sample_rate(&self) -> Result<u32, Self::Err>;
    fn get_channels(&self) -> Result<Vec<u32>, Self::Err>;
    fn get_volume(&self) -> Result<Vec<u32>, Self::Err>;
    fn set_volume(&self, value: Vec<u32>) -> Result<(), Self::Err>;
    fn get_has_flat_volume(&self) -> Result<bool, Self::Err>;
    fn get_has_convertible_to_decibel_volume(&self) -> Result<bool, Self::Err>;
    fn get_base_volume(&self) -> Result<u32, Self::Err>;
    fn get_volume_steps(&self) -> Result<u32, Self::Err>;
    fn get_mute(&self) -> Result<bool, Self::Err>;
    fn set_mute(&self, value: bool) -> Result<(), Self::Err>;
    fn get_has_hardware_volume(&self) -> Result<bool, Self::Err>;
    fn get_has_hardware_mute(&self) -> Result<bool, Self::Err>;
    fn get_configured_latency(&self) -> Result<u64, Self::Err>;
    fn get_has_dynamic_latency(&self) -> Result<bool, Self::Err>;
    fn get_latency(&self) -> Result<u64, Self::Err>;
    fn get_is_hardware_device(&self) -> Result<bool, Self::Err>;
    fn get_is_network_device(&self) -> Result<bool, Self::Err>;
    fn get_state(&self) -> Result<u32, Self::Err>;
    fn get_ports(&self) -> Result<Vec<dbus::Path<'static>>, Self::Err>;
    fn get_active_port(&self) -> Result<dbus::Path<'static>, Self::Err>;
    fn set_active_port(&self, value: dbus::Path<'static>) -> Result<(), Self::Err>;
    fn get_property_list(&self) -> Result<::std::collections::HashMap<String, Vec<u8>>, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgPulseAudioCore1Device for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn suspend(&self, suspend: bool) -> Result<(), Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.PulseAudio.Core1.Device".into(), &"Suspend".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(suspend);
        }));
        r#try!(m.as_result());
        Ok(())
    }

    fn get_port_by_name(&self, name: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.PulseAudio.Core1.Device".into(), &"GetPortByName".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(name);
        }));
        r#try!(m.as_result());
        let mut i = m.iter_init();
        let port: dbus::Path<'static> = r#try!(i.read());
        Ok(port)
    }

    fn get_index(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "Index")
    }

    fn get_name(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "Name")
    }

    fn get_driver(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "Driver")
    }

    fn get_owner_module(&self) -> Result<dbus::Path<'static>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "OwnerModule")
    }

    fn get_card(&self) -> Result<dbus::Path<'static>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "Card")
    }

    fn get_sample_format(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "SampleFormat")
    }

    fn get_sample_rate(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "SampleRate")
    }

    fn get_channels(&self) -> Result<Vec<u32>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "Channels")
    }

    fn get_volume(&self) -> Result<Vec<u32>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "Volume")
    }

    fn get_has_flat_volume(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "HasFlatVolume")
    }

    fn get_has_convertible_to_decibel_volume(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "HasConvertibleToDecibelVolume")
    }

    fn get_base_volume(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "BaseVolume")
    }

    fn get_volume_steps(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "VolumeSteps")
    }

    fn get_mute(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "Mute")
    }

    fn get_has_hardware_volume(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "HasHardwareVolume")
    }

    fn get_has_hardware_mute(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "HasHardwareMute")
    }

    fn get_configured_latency(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "ConfiguredLatency")
    }

    fn get_has_dynamic_latency(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "HasDynamicLatency")
    }

    fn get_latency(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "Latency")
    }

    fn get_is_hardware_device(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "IsHardwareDevice")
    }

    fn get_is_network_device(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "IsNetworkDevice")
    }

    fn get_state(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "State")
    }

    fn get_ports(&self) -> Result<Vec<dbus::Path<'static>>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "Ports")
    }

    fn get_active_port(&self) -> Result<dbus::Path<'static>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "ActivePort")
    }

    fn get_property_list(&self) -> Result<::std::collections::HashMap<String, Vec<u8>>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Device", "PropertyList")
    }

    fn set_volume(&self, value: Vec<u32>) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.PulseAudio.Core1.Device", "Volume", value)
    }

    fn set_mute(&self, value: bool) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.PulseAudio.Core1.Device", "Mute", value)
    }

    fn set_active_port(&self, value: dbus::Path<'static>) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.PulseAudio.Core1.Device", "ActivePort", value)
    }
}

pub fn org_pulse_audio_core1_device_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgPulseAudioCore1Device<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.PulseAudio.Core1.Device", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let suspend: bool = r#try!(i.read());
        let d = fclone(minfo);
        r#try!(d.suspend(suspend));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Suspend", Default::default(), h);
    let m = m.in_arg(("suspend", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let name: &str = r#try!(i.read());
        let d = fclone(minfo);
        let port = r#try!(d.get_port_by_name(name));
        let rm = minfo.msg.method_return();
        let rm = rm.append1(port);
        Ok(vec!(rm))
    };
    let m = factory.method("GetPortByName", Default::default(), h);
    let m = m.in_arg(("name", "s"));
    let m = m.out_arg(("port", "o"));
    let i = i.add_m(m);

    let p = factory.property::<u32, _>("Index", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_index()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Name", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_name()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("Driver", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_driver()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<dbus::Path, _>("OwnerModule", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_owner_module()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<dbus::Path, _>("Card", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_card()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("SampleFormat", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_sample_format()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("SampleRate", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_sample_rate()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<u32>, _>("Channels", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_channels()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<u32>, _>("Volume", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_volume()));
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        r#try!(d.set_volume(r#try!(iter.read())));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("HasFlatVolume", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_has_flat_volume()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("HasConvertibleToDecibelVolume", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_has_convertible_to_decibel_volume()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("BaseVolume", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_base_volume()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("VolumeSteps", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_volume_steps()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Mute", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_mute()));
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        r#try!(d.set_mute(r#try!(iter.read())));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("HasHardwareVolume", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_has_hardware_volume()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("HasHardwareMute", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_has_hardware_mute()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("ConfiguredLatency", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_configured_latency()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("HasDynamicLatency", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_has_dynamic_latency()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("Latency", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_latency()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("IsHardwareDevice", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_is_hardware_device()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("IsNetworkDevice", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_is_network_device()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("State", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_state()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<dbus::Path>, _>("Ports", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_ports()));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<dbus::Path, _>("ActivePort", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_active_port()));
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        r#try!(d.set_active_port(r#try!(iter.read())));
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<::std::collections::HashMap<&str, Vec<u8>>, _>("PropertyList", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_property_list()));
        Ok(())
    });
    let i = i.add_p(p);
    i
}

#[derive(Debug, Default)]
pub struct OrgPulseAudioCore1DeviceVolumeUpdated {
    pub volume: Vec<u32>,
}

impl dbus::SignalArgs for OrgPulseAudioCore1DeviceVolumeUpdated {
    const NAME: &'static str = "VolumeUpdated";
    const INTERFACE: &'static str = "org.PulseAudio.Core1.Device";
    fn append(&self, i: &mut arg::IterAppend) {
        (&self.volume as &arg::RefArg).append(i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.volume = r#try!(i.read());
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgPulseAudioCore1DeviceMuteUpdated {
    pub muted: bool,
}

impl dbus::SignalArgs for OrgPulseAudioCore1DeviceMuteUpdated {
    const NAME: &'static str = "MuteUpdated";
    const INTERFACE: &'static str = "org.PulseAudio.Core1.Device";
    fn append(&self, i: &mut arg::IterAppend) {
        (&self.muted as &arg::RefArg).append(i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.muted = r#try!(i.read());
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgPulseAudioCore1DeviceStateUpdated {
    pub state: u32,
}

impl dbus::SignalArgs for OrgPulseAudioCore1DeviceStateUpdated {
    const NAME: &'static str = "StateUpdated";
    const INTERFACE: &'static str = "org.PulseAudio.Core1.Device";
    fn append(&self, i: &mut arg::IterAppend) {
        (&self.state as &arg::RefArg).append(i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.state = r#try!(i.read());
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgPulseAudioCore1DeviceActivePortUpdated {
    pub port: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgPulseAudioCore1DeviceActivePortUpdated {
    const NAME: &'static str = "ActivePortUpdated";
    const INTERFACE: &'static str = "org.PulseAudio.Core1.Device";
    fn append(&self, i: &mut arg::IterAppend) {
        (&self.port as &arg::RefArg).append(i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.port = r#try!(i.read());
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgPulseAudioCore1DevicePropertyListUpdated {
    pub property_list: ::std::collections::HashMap<String, Vec<u8>>,
}

impl dbus::SignalArgs for OrgPulseAudioCore1DevicePropertyListUpdated {
    const NAME: &'static str = "PropertyListUpdated";
    const INTERFACE: &'static str = "org.PulseAudio.Core1.Device";
    fn append(&self, i: &mut arg::IterAppend) {
        (&self.property_list as &arg::RefArg).append(i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.property_list = r#try!(i.read());
        Ok(())
    }
}

pub trait OrgPulseAudioCore1Sink {
    type Err;
    fn get_monitor_source(&self) -> Result<dbus::Path<'static>, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgPulseAudioCore1Sink for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn get_monitor_source(&self) -> Result<dbus::Path<'static>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.PulseAudio.Core1.Sink", "MonitorSource")
    }
}

pub fn org_pulse_audio_core1_sink_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    T: OrgPulseAudioCore1Sink<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.PulseAudio.Core1.Sink", data);
    let f = ::std::sync::Arc::new(f);
    let p = factory.property::<dbus::Path, _>("MonitorSource", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(r#try!(d.get_monitor_source()));
        Ok(())
    });
    let i = i.add_p(p);
    i
}

pub trait OrgFreedesktopDBusIntrospectable {
    type Err;
    fn introspect(&self) -> Result<String, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgFreedesktopDBusIntrospectable for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn introspect(&self) -> Result<String, Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.freedesktop.DBus.Introspectable".into(), &"Introspect".into(), |_| {
        }));
        r#try!(m.as_result());
        let mut i = m.iter_init();
        let data: String = r#try!(i.read());
        Ok(data)
    }
}

pub fn org_freedesktop_dbus_introspectable_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopDBusIntrospectable<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Introspectable", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let data = r#try!(d.introspect());
        let rm = minfo.msg.method_return();
        let rm = rm.append1(data);
        Ok(vec!(rm))
    };
    let m = factory.method("Introspect", Default::default(), h);
    let m = m.out_arg(("data", "s"));
    let i = i.add_m(m);
    i
}

pub trait OrgFreedesktopDBusProperties {
    type Err;
    fn get(&self, interface_name: &str, property_name: &str) -> Result<arg::Variant<Box<arg::RefArg>>, Self::Err>;
    fn set(&self, interface_name: &str, property_name: &str, value: arg::Variant<Box<arg::RefArg>>) -> Result<(), Self::Err>;
    fn get_all(&self, interface_name: &str) -> Result<::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgFreedesktopDBusProperties for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn get(&self, interface_name: &str, property_name: &str) -> Result<arg::Variant<Box<arg::RefArg>>, Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"Get".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(interface_name);
            i.append(property_name);
        }));
        r#try!(m.as_result());
        let mut i = m.iter_init();
        let value: arg::Variant<Box<arg::RefArg>> = r#try!(i.read());
        Ok(value)
    }

    fn set(&self, interface_name: &str, property_name: &str, value: arg::Variant<Box<arg::RefArg>>) -> Result<(), Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"Set".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(interface_name);
            i.append(property_name);
            i.append(value);
        }));
        r#try!(m.as_result());
        Ok(())
    }

    fn get_all(&self, interface_name: &str) -> Result<::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>>, Self::Err> {
        let mut m = r#try!(self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"GetAll".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(interface_name);
        }));
        r#try!(m.as_result());
        let mut i = m.iter_init();
        let props: ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg>>> = r#try!(i.read());
        Ok(props)
    }
}

pub fn org_freedesktop_dbus_properties_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopDBusProperties<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Properties", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface_name: &str = r#try!(i.read());
        let property_name: &str = r#try!(i.read());
        let d = fclone(minfo);
        let value = r#try!(d.get(interface_name, property_name));
        let rm = minfo.msg.method_return();
        let rm = rm.append1(value);
        Ok(vec!(rm))
    };
    let m = factory.method("Get", Default::default(), h);
    let m = m.in_arg(("interface_name", "s"));
    let m = m.in_arg(("property_name", "s"));
    let m = m.out_arg(("value", "v"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface_name: &str = r#try!(i.read());
        let property_name: &str = r#try!(i.read());
        let value: arg::Variant<Box<arg::RefArg>> = r#try!(i.read());
        let d = fclone(minfo);
        r#try!(d.set(interface_name, property_name, value));
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Set", Default::default(), h);
    let m = m.in_arg(("interface_name", "s"));
    let m = m.in_arg(("property_name", "s"));
    let m = m.in_arg(("value", "v"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface_name: &str = r#try!(i.read());
        let d = fclone(minfo);
        let props = r#try!(d.get_all(interface_name));
        let rm = minfo.msg.method_return();
        let rm = rm.append1(props);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAll", Default::default(), h);
    let m = m.in_arg(("interface_name", "s"));
    let m = m.out_arg(("props", "a{sv}"));
    let i = i.add_m(m);
    i
}
